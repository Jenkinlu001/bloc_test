 #  C++构造函数的理解
 相对于C语言来说，C++有一个比较好的特性就是构造函数，即类通过一个或者几个特殊的成员函数来控制其对象的初始化过程。构造函数的任务，就是初始化对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。     
 
 ## 构造函数的语法
 构造函数的名字必须和类名相同，与其他函数不一样的是，构造函数没有返回值，而且其必须是公有成员，因为私有成员不允许外部访问，且函数不能声明为const类型，构造函数的语法是这样的：

    class Test
    {
        public:
            Test(){std::cout<<"Hello world!"<<std::endl;}
    };
    Test object; 
    int main(){return 1;}
在main函数执行之前，object被定义时就会调用Test函数，输出"Hello world!"。  
这里只是示范了一个最简单的构造函数的形式，其实构造函数是个比较复杂的部分，有非常多神奇的特性。    

## 构造函数的种类
### 默认构造函数
当我们程序中并没有显式的定义构造函数时，系统会提供一个默认的构造函数，这种编译器创建的构造函数又被称为合成的默认构造函数，合成构造函数的初始化规则是这样的：
* 如果存在类内的初始值，用它来初始化成员。在C++11的新特性中，C++11支持为类内的数据成员提供一个初始值，创建对象时，类内初始值将用于初始化数据成员。如果在构造函数中又显式地初始化了数据成员，则使用显式初始化的值。   
*  否则，默认初始化该成员。默认初始化意味着和C语言一样的初始化方式，当类对象为全局变量时，在系统加载时初始化为0，而作为局部变量时，由于数据在栈上分配，成员变量值不确定。  
需要注意的是，只有当用户没有显式地定义构造函数时，编译器才会为其定义默认构造函数。  
在某些情况下，默认构造函数是不合适的：
* 如上所说，内部定义的类调用默认构造函数会导致成员函数的值是未定义的。  
* 如果类中包含其他类类型的数据成员或者继承自其他类，且这个类没有默认构造函数，那么编译器将无法初始化该成员。上面提到了可以在类内给成员一个初始值，但是这只对于普通变量，并不支持类的构造。 
当我们除了自定义的其他构造函数，还需要一个默认构造函数时，我们可以这样定义：

    Test() = default；
这个构造函数不接受任何参数，等于默认构造函数。

### 初始化列表的构造方式
首先，我们先需要分清初始化和赋值的概念，初始化就是在新创建对象的时候给予初值，而赋值是在两个已经存在的对象之间进行操作。在构造方式上，这两种是不同的。   
构造函数支持初始化列表，它负责为新创建的对象的一个或者几个数据成员赋初值，初始化列表的语法是这样的：

    class Test
    {
        public:
            Test(int a):x(a),y(2){}
            int x;
            int y；
    };
初始化的列表的一个优势是时间效率和空间效率比赋值要高，同时在const类型成员的构造时，普通的赋值构造函数是非法的。***当我们创建一个const对象时，知道构造函数完成初始化过程，对象才能真正取得其常量属性。***  
所以我们可以用这种方式为const成员变量写值。  

### 拷贝构造函数
拷贝构造函数的一般形式是这样的：

    class Test
    {
        public:
            Test(Test &ob){
                x = ob.x;
                y = ob.y;
            }
        private:
            int x;
            int y；
    };
可以很清楚地看出来，构造过程就是将另一个同类对象的成员变量一一赋值。看到上面的示例，不知道有没有朋友有所疑问:  
为什么在构造函数中，用户可以访问到外部同类对象ob的私有变量，不是说私有变量只能通过类的公共函数(一般是get()方法)来访问吗，为什么这里可以直接使用ob.x,ob.y ??
如果你有这样的问题，首先不得不承认你是个善于观察且有一定基础的学者，但是对封装的概念并不是很清楚。  
其实不仅仅构造函数可以访问同类对象的私有变量，普通成员函数也可以访问，如果有兴趣的话你可以上机试试，毕竟实践才能出真知。  

默认拷贝构造函数！！！



右值引用，右值引用没有其他引用

构造函数的隐式转换以及拒绝隐式转换的问题

 类外部定义无法带初始化列表

 错误地定义类：test dst();这是申明函数，而不是定义类。
 
 深拷贝浅拷贝
 
 为什么拷贝构造访问私有问题、