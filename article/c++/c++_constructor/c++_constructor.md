 #  C++构造函数的理解
 相对于C语言来说，C++有一个比较好的特性就是构造函数，即类通过一个或者几个特殊的成员函数来控制其对象的初始化过程。构造函数的任务，就是初始化对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。     
 
 ## 构造函数的语法
 构造函数的名字必须和类名相同，与其他函数不一样的是，构造函数没有返回值，而且其必须是公有成员，因为私有成员不允许外部访问，且函数不能声明为const类型，构造函数的语法是这样的：

    class Test
    {
        public:
            Test(){std::cout<<"Hello world!"<<std::endl;}
    };
    Test object; 
    int main(){return 1;}
在main函数执行之前，object被定义时就会调用Test函数，输出"Hello world!"。  
这里只是示范了一个最简单的构造函数的形式，其实构造函数是个比较复杂的部分，有非常多神奇的特性。    

## 构造函数的种类
### 默认构造函数
当我们程序中并没有显式的定义构造函数时，系统会提供一个默认的构造函数，这种编译器创建的构造函数又被称为合成的默认构造函数，合成构造函数的初始化规则是这样的：
* 如果存在类内的初始值，用它来初始化成员。在C++11的新特性中，C++11支持为类内的数据成员提供一个初始值，创建对象时，类内初始值将用于初始化数据成员。如果在构造函数中又显式地初始化了数据成员，则使用显式初始化的值。   
*  否则，默认初始化该成员。默认初始化意味着和C语言一样的初始化方式，当类对象为全局变量时，在系统加载时初始化为0，而作为局部变量时，由于数据在栈上分配，成员变量值不确定。  
需要注意的是，只有当用户没有显式地定义构造函数时，编译器才会为其定义默认构造函数。  
在某些情况下，默认构造函数是不合适的：
* 如上所说，内部定义的类调用默认构造函数会导致成员函数的值是未定义的。  
* 如果类中包含其他类类型的数据成员或者继承自其他类，且这个类没有默认构造函数，那么编译器将无法初始化该成员。上面提到了可以在类内给成员一个初始值，但是这只对于普通变量，并不支持类的构造。 
当我们除了自定义的其他构造函数，还需要一个默认构造函数时，我们可以这样定义：

    Test() = default；
这个构造函数不接受任何参数，等于默认构造函数。

### 初始化列表的构造方式
首先，我们先需要分清初始化和赋值的概念，初始化就是在新创建对象的时候给予初值，而赋值是在两个已经存在的对象之间进行操作。在构造方式上，这两种是不同的。   
构造函数支持初始化列表，它负责为新创建的对象的一个或者几个数据成员赋初值，初始化列表的语法是这样的：

    class Test
    {
        public:
            Test(int a):x(a),y(2){}
            int x;
            int y；
    };
初始化的列表的一个优势是时间效率和空间效率比赋值要高，同时在const类型成员的构造时，普通的赋值构造函数是非法的。***当我们创建一个const对象时，知道构造函数完成初始化过程，对象才能真正取得其常量属性。***  
所以我们可以用这种方式为const成员变量写值。  

### 拷贝构造函数
拷贝构造函数的一般形式是这样的：

    class Test
    {
        public:
            Test(const Test &ob){
                x = ob.x;
                y = ob.y;
            }
        private:
            int x;
            int y；
    };
可以很清楚地看出来，构造过程就是将另一个同类对象的成员变量一一赋值，const修饰是因为限定传入对象的只读属性。看到上面的示例，不知道有没有朋友有所疑问:  
为什么在构造函数中，用户可以访问到外部同类对象ob的私有变量，不是说私有变量只能通过类的公共函数(一般是get()方法)来访问吗，为什么这里可以直接使用ob.x,ob.y ??
如果你有这样的问题，首先不得不承认你是个善于观察且有一定基础的学者，但是对封装的概念并不是很清楚。  
其实不仅仅构造函数可以访问同类对象的私有变量，普通成员函数也可以访问:

    class Test
    {
        public:
            Test(){};
            void func(const Test& ob){
                std::cout<<ob.x<<std::endl;
            }
            
        private:
            int x=2;
    };
这样的写法不会报错且能够正常运行，但是如果func()的函数是这样的：

    void func(const AnotherClass& ob){
                std::cout<<ob.x<<std::endl;
            }
那我们还能不能访问ob的私有变量呢？答案肯定是不行的，这不用说。那我们回到上面的问题，为什么可以访问同类对象的私有变量？  
其实答案并不难理解，类的封装性是针对类而不是针对类对象。  
通俗地来说，我们定义类中成员访问权限的初衷是为了保护私有成员不被外部其他对象访问到，一般情况下私有成员被外部访问的方式就是通过公共的函数接口(public)，而在类的内部，任何成员函数都能访问私有成员，这种保护是针对不同的类之间的，所以我们是在定义类的时候来指定访问权限，而不是在定义对象的时候再指定访问权限。  
再者，相同类对象，对于所有的私有变量，彼此知根知底，也就没有什么保护的必要。      
既然是这样，类内的构造函数以及其它函数都是类的成员函数，自然可以访问所有数据。


### 赋值运算符重载
同时，类的构造可以用重载赋值运算符来实现，即"="。

    class Test
    {
        public:
            Test& operator=(const Test &ob){
                x = ob.x;
                y = ob.y;
                return this;
            }
        private:
            int x;
            int y;
    };
在定义类的时候，我们可以这样：

    Test ob1;
    Test ob2 = ob1;

### 默认拷贝构造函数的陷阱
当我们没有指定拷贝构造函数或者没有重载赋值运算符时，系统会生成默认的对应构造函数，分别为合成拷贝构造函数和合成拷贝赋值运算符。即使用户没有在类中定义相对应拷贝赋值操作，我们照样可以使用它：

    Test ob1;
    Test ob2(ob1);
    Test ob3 = ob2;
编译器生成的默认拷贝赋值构造函数会将对应的成员一一赋值，是不是非常方便？  
既然编译器生成的默认拷贝赋值构造函数就能完成任务，为什么我们还要自己去定义构造函数呢？这是不是多此一举？  
非也！！！  
如果类型成员全部都是普通变量是没有问题的，但是如果涉及到指针，简简单单地复制指针也是没有问题的，最要命的是如果指针指向的动态内存，这样就会有两个不同类的成员指向同一片动态内存，而析构函数在释放内存时，必然造成double free，我们可以看下面的例子：

    class Test
    {
        public:
            Test(){p = new int(4);}
            ~Test(){delete p;}
            int *p;
    };
    Test ob1;
    Test ob2 = ob1;
    int main(){}
然后编译运行：

    g++ -std=c++11 test.cpp -o test
    ./test
这段程序不做任何事，仅仅是通过编译器生成的合成拷贝赋值运算符，运行结果：

    *** Error in `./a.out': double free or corruption (fasttop): 0x085dca10 *** Aborted (core dumped)
很明显，和上面所提到的一样，动态内存的double free导致程序终止。为了观众朋友们能更清晰地理解这个过程，我们再来对程序做一个step by step解析：
* 构造类对象ob1，这是调用了构造函数，为ob1.p分配了内存空间。
* 用合成拷贝赋值构造函数构造类对象ob2 = ob1，相当于执行了语句：ob2.p = ob1.p;
* main()函数执行完毕，全局函数的运行周期结束，系统回收内存，先调用ob1的析构函数，将ob1.p指向的内存释放。
* 调用ob2的析构函数，将ob2.p指向的内存释放，但是由于ob2.p的内存已经在上一步被释放，所以造成了double free。  
事实上，这种现象在C++中有两个专用名词来描述："浅拷贝"和"深拷贝"。  
所以，在使用编译器默认的合成构造函数时，我们要非常小心这一类的陷阱，即使是目前没有指针成员函数，也要自己写拷贝赋值构造函数，这样有利于代码的扩展和维护。  
但是，话说话来，如果我每次实现一个很简单的需求，都要定义复制拷贝构造函数，一个一个成员去赋值，这样也是很烦人的，在新标准下，C++提供了一种方法来"解决"这个问题。  
#### 阻止拷贝
用户可以禁止使用拷贝函数，只要作这样声明：

    Test(Test &ob) = delete;
    Test &operator(Test &ob) = delete;
    事实上，部分编译器默认禁止合成的拷贝赋值构造函数。
这样，在使用者想使用默认的拷贝赋值构造函数时，编译器将无情地报错。  
*** 

### 移动构造函数
在说到移动构造函数之前，我们得先介绍一下新标准下一种新的引用类型——右值引用。右值引用就是必须绑定到右值的引用，左值的引用用&，而右值的引用则用&&。右值引用有一个重要的性质，即只能绑定到一个将要销毁的对象。

    通俗地说，右值通常为临时变量，字面值，未接受的返回值等等，它们没有固定地址。
    而左值通常是变量。总而言之，左值持久，右值短暂。
下面是引用和右值引用的示例：

    int x = 30;
    int &r = x;  //正确，左值引用
    int &&r = x; //错误，x为左值，&&r为右值引用
    int &&r = 3; //正确，右值引用
    const int &r = 3;  //正确，const左值可以对右值引用
由于右值引用只能绑定到临时对象，我们可以知道它的特点：
* 所引用的对象将要被销毁
* 该对象没有其他用户
这两个特性则意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。可想而知，右值引用的特点是"窃取"而不是"生成",在效率上自然就有所提高。  

如果现在有一个左值，我们想将它作为右值来处理，应该怎么办呢？答案是std::move()函数，语法是这样的：

    int x = 30;
    int &&r = std::move(x); 
但是正如右值的特性而言，将左值转换成右值的时候，你得确保这个左值将不再使用，建议使用std::move()，因为这样的函数名总是容易出现命名冲突。  

让我们再回到移动构造函数，各位朋友们应该从前面的铺垫已经猜到了这是个什么样的实现，是的，它的特点就是接受一个右值作为参数来进行构造。实现是这样的：

    class Test
    {
        public:
            Test(){}
            Test(Test &&ob){
                p = ob.p;
            }
            int *p;
    };



右值引用，右值引用没有其他引用

构造函数的隐式转换以及拒绝隐式转换的问题

 类外部定义无法带初始化列表

 错误地定义类：test dst();这是申明函数，而不是定义类。
 
 深拷贝浅拷贝
 
 为什么拷贝构造访问私有问题、