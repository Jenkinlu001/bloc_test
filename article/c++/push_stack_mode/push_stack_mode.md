## C/C++的函数调用模式
### C语言的经典swap问题
在学习C语言的时候，我们大都遇到过一些经典例题，这些经典例题背后所代表的是往往是C/C++背后的一些运行原理，比如下面这个示例：

    请问下面这个swap()函数能否用来进行值交换?
    void swap(int x,int y)
    {
        int temp=x;
        x=y;
        y=temp;
    }
稍微有些经验的程序员肯定要脱口而出：不行！！  
为什么不行呢？  
这个题我都看过十遍了，因为要用指针！！  
好吧，确实是要用指针，估计十个人有九个能写出标准答案：

    void swap(int *px,int *py)
    {
        int temp=*px;
        *px=*py;
        *py=temp;
    }
嗯，非常不错！那我们再来做做这个题：

    下面这个swap函数能否用来进行值交换？
    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        py = p;
    }
到这里，基本上就会有两个声音：
* 可以交换，因为用指针是可以的
* 不能交换
是骡子是马，拉出来遛遛！我们来实践出真知：

    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        py = p;
    }
    int main(int argc,char *argv[])
    {
        int a=3,b=5;
        printf("Before swap:%d %d\n",a,b);
	    swap(&a,&b);
	    printf("After swap:%d %d\n",a,b);
	    return 0;
    }
编译运行，输出结果为：
    Before swap:3 5
    After swap:3 5

结果是不能交换，不是用了指针么，为什么会是这样的结果？  
这得从C语言的函数调用机制说起。

### 程序的运行
首先，我们需要知道的是，程序是怎么运行的？  
从底层角度来看：我们将源代码经过编译链接阶段生成二进制可执行文件，即bin文件。单片机系统则是下载到片内flash中，上电启动程序(在操作系统中运行这个可执行文件)，先是将文件加载到内存中，然后CPU从内存中读取指令到内部寄存器，再操作内部寄存器中的数据，执行完成之后将内部寄存器中的值写回内存，外设寄存器映射到相应的地址中，当需要操作硬件外设时，就对外设映射地址上的数据进行操作，如GPIO/I2C/SPI/TIMER等等。(这只是大概流程，具体实现会更复杂，这里不过多描述)，其实CPU的运行就是对数据的处理过程。
从程序代码的角度来看：一般情况下，程序从main()函数开始(main()是开发者可见的程序入口，但事实上main()函数也是被系统调用的一个函数，这里不过多赘述)，程序按顺序执行，当遇到函数调用时，执行被调用函数，等被调用函数执行完毕(递归调用通常是存在的)，函数返回，继续执行main()函数，直到程序结束(而在操作系统中是进程结束)。


### 函数调用的过程
#### 栈
即使是现在的MCU，内部寄存器的资源也是极其有限，以目前非常流行的Cortex M3为例，15个内部寄存器，除去三个特殊寄存器(SP,PC,LR),共有12个通用寄存器，由于是32bit MCU，所以即使在极限状态下，寄存器也只能存几十个字节的数据。所以一旦出现函数调用时，需要保存当前数据和状态，内部寄存器是完全不够用的。    
而栈就是从专门内存中开辟出来用于保存程序运行时状态的内存结构。  
很多朋友对栈并不陌生，知道这是一种先进后出的数据结构，就像我们堆货物，后来的放在上面，取得时候也是先取最上层的。  
这里所说的栈不是数据结构，但是它也是遵循这个原理的内存实现。
#### 实参和形参
我们都知道函数是带有参数的，在函数定义和声明时，这时候指定的参数叫形参，即形式参数，是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数.在调用函数时，实参将赋值给形参。而在真正函数调用的时候，传入的参数叫实参，即实际参数，实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。
#### 函数调用时栈的状态
首先，我们继续看上面那份代码：

    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        py = p;
    }
    int main(int argc,char *argv[])
    {
        int a=3,b=5;
	    swap(&a,&b);
	    return 0;
    }
在上述代码中，我们可以看到，在main()函数中调用了swap()函数，我们来看看在这个执行过程中发生了什么？
1. 系统将函数返回地址压栈。
2. 系统在栈上为被调用函数的参数分配地址空间，将实参的值传递给形参
3. 系统为被调用函数的局部变量分配内存空间
4. 如果出现函数的嵌套调用，重复1-3过程
5. 函数执行结束，如果有返回值，将返回值放入寄存器(如果返回值size太大，则放在内存)
6. 将栈上数据一个个弹出，销毁栈上数据，注意这里的销毁并非为真正的销毁，只是不再去管它，并不会置0或者置1,这也是为什么局部变量未初始化时的值不确定，因为它的值就是上一次执行栈中的值。
7. 取出返回地址，将返回地址装入PC指针(程序计数器，指向下一条将要执行的指令地址)，函数返回。
8. 如果被调用函数有返回值，取回返回值，继续执行函数。
这就是整个函数调用过程(这是基础实现，部分具体实现会加入一些其他信息)。  
#### 再回到swap函数的结果
让我们来看看上述函数调用过程中的第二步，即系统在栈上为形参分配地址空间，将实参的值传递给形参。所以，从这里我们可以知道，形参和实参是两个地址独立的变量，参数传递时事实上是变量值的传递，即传值。  
很多人提到参数传递有传值和传址两种方式，但是事实上传址是传值的其中一种形式，本质上传址传的是指针变量的值(即地址值)，也是一种值传递，所以严格来说是没有传址和传值的区分的。  
需要声明的是，指针是一种数据类型,int*,char*等等，和int,char是同一个概念，
而类似

    int *p,
    char* str
和

    int i
    char c
是同一种行为，所以这里的p，str事实上是变量，只不过变量的值是地址。而不是某些书上说的"指针就是地址"，搞清这个问题才能对指针有更清晰的了解。  
##### 我们回过头来看第一个swap函数为什么不能交换：

    void swap(int x,int y)
    {
        int temp=x;
        x=y;
        y=temp;
    }
我们调用这个函数，例如：

    int a=3,b=5;
    swap(a,b)
经过上面的讨论，我们知道，系统在栈上给形参x，y分配了内存空间，然后将a的值赋值给x，b的值赋值给y，相当于进行了这样的操作：

    x=a=3;
    y=b=5;
在函数执行的过程中，x与y成功进行了swap交换，即函数执行完，结果是这样的：

    x:5
    y:3
但是根据我们列出的函数调用过程的第6点可以看到，在函数运行完之后，x和y被销毁，这次x，y的交换行为根本没有意义，因为a，b根本没有参与到函数执行中来。  
##### 那为什么第二个函数就可以交换成功呢？
 
    void swap(int *px,int *py)
    {
        int temp=*px;
        *px=*py;
        *py=temp;
    }
我们依旧调用这个函数：
    
    int a=3,b=5;
    //我们假设a的地址为0x1000，b的地址为0x1004
    swap(&a,&b);
在这次调用中，系统为px，py分配空间(px和py为指针类型)，然后将a，b的地址赋值给px，py，相当于执行了这样的操作：

    px=&a=0x1000;
    py=&b=0x1004;
接下来的三行代码：

    int temp=*px;
    *px=*py;
    *py=temp;
用通俗的语言描述就是：

    系统取出px的值即0x1000，找到地址0x1000上存储的变量，即a，将a赋值给temp,同temp=a;
    系统取出py的值即0x1004，找到地址0x1004上存储的变量，即b，再取出px的值即0x1000，找到0x1000上存储的变量，即a，将b赋值给a,同a=b。
    系统取出temp的值即原a的值，取出py的值即0x1004，找到地址0x1004上存储的变量即b，将temp的值赋值给b，同b=temp。
    函数结束，px，py被销毁,此时a,b的值已进行交换。

##### 那我们再来看看第三个swap函数为什么不能成功交换。

    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        py = p;
    }
我们还是调用这个函数，来一步步地分析：

    int a=3,b=5;
    //我们假设a的地址为0x1000，b的地址为0x1004
    swap(&a,&b);
接下来的三行代码：

    p = px;
    px = py;
    py = p;
用通俗的语言表达就是：
    系统取出px的值即0x1000，将px的值赋值给p，此时p=0x1000;
    系统取出py的值即0x1004，将py的值赋值给px,此时px=0x1004；
    将p赋值给px，即px=0x1000；
    函数结束，px，py被销毁，此时a,b的值不受任何影响。
看到这里，我想你应该看出答案了，这个swap和第一个swap实现其实就是换汤不换药，仅仅是将形参进行了互换，而a，b没受到任何影响。  
由此可见，这种参数传递问题根本就不能以是否是指针这种死板的方式来判断是否有效。  
#### 思考
我想大家都应该已经懂了参数传递的原理，我来出个小题来验证一下：

    请问，下面的释放动态内存的函数有什么问题？
    void myFree(char *ptr){     //ptr为指向动态内存的指针
        free(ptr);
        ptr=NULL;
        return;
    }


### 可变参数函数原理
栈帧结构
从汇编中找证据
可变参数函数。