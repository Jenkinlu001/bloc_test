## C/C++的函数调用模式
### C语言的经典swap问题
在学习C语言的时候，我们大都遇到过一些经典例题，这些经典例题背后所代表的是往往是C/C++背后的一些运行原理，比如下面这个示例：

    请问下面这个swap()函数能否用来进行值交换?
    void swap(int x,int y)
    {
        int temp=x;
        x=y;
        y=temp;
    }
稍微有些经验的程序员肯定要脱口而出：不行！！  
为什么不行呢？  
这个题我都看过十遍了，因为要用指针！！  
好吧，确实是要用指针，估计十个人有九个能写出标准答案：

    void swap(int *px,int *py)
    {
        int temp=*px;
        *px=*py;
        *py=temp;
    }
嗯，非常不错！那我们再来做做这个题：

    下面这个swap函数能否用来进行值交换？
    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        py = p;
    }
关于这个题的答案有两种看法：
* 可以交换，因为用指针是可以的
* 不能交换
是骡子是马，拉出来遛遛！我们来实践出真知：

    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        py = p;
    }
    int main(int argc,char *argv[])
    {
        int a=3,b=5;
        printf("Before swap:%d %d\n",a,b);
	    swap(&a,&b);
	    printf("After swap:%d %d\n",a,b);
	    return 0;
    }
编译运行，输出结果为：
    Before swap:3 5
    After swap:3 5

结果是不能交换，不是用了指针么，为什么会是这样的结果？？



这得从C语言的函数调用机制说起。

### 程序的运行
首先，我们需要知道的是，程序是怎么运行的？  
从底层角度来看：我们将源代码经过编译链接阶段生成二进制可执行文件，即bin文件。单片机系统则是下载到片内flash中，上电启动程序(在操作系统中运行这个可执行文件)，先是将文件加载到内存中，然后CPU从内存中读取指令到内部寄存器，再操作内部寄存器中的数据，执行完成之后将内部寄存器中的值写回内存，外设寄存器映射到相应的内存地址中，当需要操作硬件外设时，就对外设映射地址上的数据进行操作，如GPIO/I2C/SPI/TIMER等等。(这只是大概流程，具体实现会更复杂，这里不过多描述)，其实CPU的运行就是对数据的处理过程。
从程序代码的角度来看：一般情况下，程序从main()函数开始(main()是开发者可见的程序入口，但事实上main()函数也是被系统调用的一个函数，这里不再赘述)，程序按顺序执行，当遇到函数调用时，执行被调用函数，等被调用函数执行完毕(递归调用通常是存在的)，函数返回，继续执行main()函数，直到程序结束(而在操作系统中是进程结束)。


### 函数调用的过程
#### 栈
即使是现在的MCU，内部寄存器的资源也是极其有限，以目前非常流行的Cortex M3为例，15个内部寄存器，除去三个特殊寄存器(SP,PC,LR),共有12个通用寄存器，由于是32bit MCU，所以即使在极限状态下，寄存器也只能存几十个字节的数据。所以一旦出现函数调用时，需要保存当前数据和状态，内部寄存器是完全不够用的。    
而栈就是从专门内存中开辟出来用于保存程序运行时状态的内存结构。  
很多朋友对栈并不陌生，知道这是一种先进后出的数据结构，就像我们堆货物，后来的放在上面，取得时候也是先取最上层的。  
这里所说的栈不是数据结构，但是它也是遵循这个原理的内存实现。  
#### 实参和形参
我们都知道函数是带有参数的，在函数定义和声明时，这时候指定的参数叫形参，即形式参数，是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数.在调用函数时，实参将赋值给形参。而在真正函数调用的时候，传入的参数叫实参，即实际参数，实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。
#### 函数调用时栈的状态
首先，我们继续看上面那份代码：

    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        py = p;
    }
    int main(int argc,char *argv[])
    {
        int a=3,b=5;
	    swap(&a,&b);
	    return 0;
    }
在上述代码中，我们可以看到，在main()函数中调用了swap()函数，我们来看看在这个执行过程中发生了什么？
1. 系统将参数压栈。
2. 系统将函数返回地址压栈。
3. 系统为被调用函数的局部变量分配内存空间
4. 如果出现函数的嵌套调用，重复1-3过程
5. 函数执行结束，如果有返回值，将返回值放入寄存器(如果返回值size太大，则放在内存)
6. 读取栈上返回地址，函数返回。
这就是整个函数调用过程(这只是与参数返回值相关的调用结构，实际的实现要复杂得多，会涉及到数据对齐、上下文的保存等具体问题)。  
#### 再回到swap函数的结果
让我们来看看上述函数调用过程中的第三步，即系统在栈上为局部变量(包括形参)分配地址空间，将寄存器中实参的值传递给形参。所以，从这里我们可以知道，形参和实参是两个地址独立的变量，参数传递时事实上是变量值的传递，即传值。  
很多人提到参数传递有传值和传址两种方式，但是事实上传址是传值的其中一种形式，本质上传址传的是指针变量的值(即地址值)，也是一种值传递，所以严格来说是没有传址和传值的区分的。  
需要声明的是，指针是一种数据类型,int*,char*等等，和int,char是同一个概念，
而类似

    int *p,
    char* str
和

    int i
    char c
是同一种行为，所以这里的p，str事实上是变量，只不过变量的值是地址。而不是某些书上说的"指针就是地址"，搞清这个问题才能对指针有更清晰的了解。  
##### 我们回过头来看第一个swap函数为什么不能交换：

    void swap(int x,int y)
    {
        int temp=x;
        x=y;
        y=temp;
    }
我们调用这个函数，例如：

    int a=3,b=5;
    swap(a,b)
经过上面的讨论，我们知道，系统在栈上给形参x，y分配了内存空间，然后将a的值赋值给x，b的值赋值给y，相当于进行了这样的操作：

    x=a=3;
    y=b=5;
在函数执行的过程中，x与y成功进行了swap交换，即函数执行完，结果是这样的：

    x:5
    y:3
但是根据我们列出的函数调用过程的第6点可以看到，在函数运行完之后，x和y被销毁，这次x，y的交换行为根本没有意义，因为a，b根本没有参与到函数执行中来。  
##### 那为什么第二个函数就可以交换成功呢？
 
    void swap(int *px,int *py)
    {
        int temp=*px;
        *px=*py;
        *py=temp;
    }
我们依旧调用这个函数：
    
    int a=3,b=5;
    //我们假设a的地址为0x1000，b的地址为0x1004
    swap(&a,&b);
在这次调用中，系统为px，py分配空间(px和py为指针类型)，然后将a，b的地址赋值给px，py，相当于执行了这样的操作：

    px=&a=0x1000;
    py=&b=0x1004;
接下来的三行代码：

    int temp=*px;
    *px=*py;
    *py=temp;
用通俗的语言描述就是：

    系统取出px的值即0x1000，找到地址0x1000上存储的变量，即a，将a赋值给temp,同temp=a;
    系统取出py的值即0x1004，找到地址0x1004上存储的变量，即b，再取出px的值即0x1000，找到0x1000上存储的变量，即a，将b赋值给a,同a=b。
    系统取出temp的值即原a的值，取出py的值即0x1004，找到地址0x1004上存储的变量即b，将temp的值赋值给b，同b=temp。
    函数结束，px，py被销毁,此时a,b的值已进行交换。

##### 那我们再来看看第三个swap函数为什么不能成功交换。

    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        py = p;
    }
我们还是调用这个函数，来一步步地分析：

    int a=3,b=5;
    //我们假设a的地址为0x1000，b的地址为0x1004
    swap(&a,&b);
接下来的三行代码：

    p = px;
    px = py;
    py = p;
用通俗的语言表达就是：
    系统取出px的值即0x1000，将px的值赋值给p，此时p=0x1000;
    系统取出py的值即0x1004，将py的值赋值给px,此时px=0x1004；
    将p赋值给px，即px=0x1000；
    函数结束，px，py被销毁，此时a,b的值不受任何影响。
看到这里，我想你应该看出答案了，这个swap和第一个swap实现其实就是换汤不换药，仅仅是将形参进行了互换，而a，b没受到任何影响。  
由此可见，这种参数传递问题根本就不能以是否是指针这种死板的方式来判断是否有效。  
#### 思考
我想大家都应该已经懂了参数传递的原理，我来出个小题来验证一下：

    请问，下面的释放动态内存的函数有什么问题？
    void myFree(char *ptr){     //ptr为指向动态内存的指针
        free(ptr);
        ptr=NULL;
        return;
    }
欢迎大家留言讨论。
***

##### 或许你以为这一章到这里就结束了，不！！！这还只是个开始，在上面我们剖析swap()函数实现时提到了一些关于函数调用时栈的活动，接下来我们要详细地讨论一下栈实现的细节部分。

### 细说函数调用
#### 栈帧结构
在经典操作系统中，栈总是向下生长的，向下生长意味着由高地址向低地址延伸，当数据压栈时，栈向低地址延伸，当从栈中弹出数据时，栈缩回高地址。  
在这里我们需要了解到一个概念，栈帧结构(可以通俗翻译为堆栈活动记录)，这个结构涉及到两个内部寄存器：esp和ebp。
#### esp和ebp
在经典X86系统中，esp指向栈顶，而ebp指向当前调用函数的栈底(注意是当前调用函数而不是整个栈的栈底),由ebp指针进行栈上的参数寻址。
我们来分析函数调用时栈活动记录的细节：
首先，还是准备一个简单的函数：

    int firstFunc(int x,int y){
        return x+y;}

    int main(){
        int c=firstFunc(3,5);
        return 1;
    }
它所对应的函数调用时栈活动是这样的：

光贴出这么一张图，估计很多朋友是懵逼的，下面我们就来解释一下。  
* 在main()函数调用firstFunc()之前，ebp指向main()函数的基地址，而在调用firstFunc()时，ebp指向新函数的栈基地址，即指向firstFunc()函数基地址，此时ebp为firstFunc()函数的栈底，但是栈底之上的第一次四字节就是放的main()函数的栈底指针。

* esp则一直指向当前函数栈顶，当发生函数调用时，直接将用ebp替代esp指向当前函数栈顶即被调用函数的栈基地址。

* 当函数返回时，由于ebp的指向部分的第一个元素为旧ebp，所以直接用旧ebp赋值给ebp即可，esp则返回到ebp的位置(因为在函数调用时，将esp的值赋值给了ebp，这里返回到函数调用之前的状态)。  

既然是底层分析，那么就不能空口无凭，我们来一段硬货：上反汇编代码：
编译上述的代码文件，然后用objdump指令进行反汇编，将结果重定向到文件：

    gcc -g test.c -o test
    objdump -S test > test.file
注意这里的编译需要添加 -g 参数，那为什么要用反汇编而不是直接用gcc 的-E指令生成汇编指令呢？  
因为直接编译生成的汇编指令是纯汇编指令，晦涩难懂，但是经过objdump反汇编出来的代码嵌入了源代码，更方便对照。  
下面是部分结果：***注意由于平台原因，这里的栈帧是rbp和rsp，而不是早期的ebp和esp。***

    int firstFunc(int x,int y)
    {
    4004d6:	55                   	push   %rbp               //将rbp的值压栈
    4004d7:	48 89 e5             	mov    %rsp,%rbp          //将rsp的值赋值给rbp
    4004da:	89 7d fc             	mov    %edi,-0x4(%rbp)    //将edi寄存器中的值放在rbp-4的位置，即压栈(压栈时向低地址延伸)
    4004dd:	89 75 f8             	mov    %esi,-0x8(%rbp)    //将esi寄存器中的值放在rbp-8的位置。
        return x+y;
    4004e0:	8b 55 fc             	mov    -0x4(%rbp),%edx    //将rbp-4位置的值放入edx寄存器
    4004e3:	8b 45 f8             	mov    -0x8(%rbp),%eax    //将rbp-8位置的值放入eax寄存器
    4004e6:	01 d0                	add    %edx,%eax          //将edx寄存器的值+eax寄存器中的中，结果放在eax中，作为返回值
    }
    4004e8:	5d                   	pop    %rbp               //函数即将返回，将rbp还原(rbp指向的首地址出存放的是调用函数的rbp栈基地址)
    4004e9:	c3                   	retq                      //返回

    00000000004004ea <main>:
    int main()
    {
    4004ea:	55                   	push   %rbp
    4004eb:	48 89 e5             	mov    %rsp,%rbp
    4004ee:	48 83 ec 10          	sub    $0x10,%rsp             //为函数的执行分配内存空间
        //int a=3,b=5;
        int c=firstFunc(3,5);
    4004f2:	be 05 00 00 00       	mov    $0x5,%esi             //将实参5放入寄存器esi中
    4004f7:	bf 03 00 00 00       	mov    $0x3,%edi             //将实参3放入寄存器edi中
    4004fc:	e8 d5 ff ff ff       	callq  4004d6 <firstFunc>    //执行函数
    400501:	89 45 fc             	mov    %eax,-0x4(%rbp)       //将eax的值取出来，因为调用了firstFunc，eax中存的是返回值，这里是读出返回值。
        return 1;
    400504:	b8 01 00 00 00       	mov    $0x1,%eax             //将返回值1放入eax寄存器
    }
反汇编出来的是AT&T格式的汇编代码，如果不懂汇编代码的直接看我添加的注释部分。



### 可变参数函数原理
栈帧结构
从汇编中找证据
可变参数函数。