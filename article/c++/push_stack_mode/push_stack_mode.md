## C/C++的函数调用模式
### C语言的经典swap问题
在学习C语言的时候，我们大都遇到过一些经典例题，这些经典例题背后所代表的是往往是C/C++背后的一些运行原理，比如下面这个示例：

    请问下面这个swap()函数能否用来进行值交换?
    void swap(int x,int y)
    {
        int temp=x;
        x=y;
        y=temp;
    }
稍微有些经验的程序员肯定要脱口而出：不行！！  
为什么不行呢？  
这个题我都看过十遍了，因为要用指针！！  
好吧，确实是要用指针，估计十个人有九个能写出标准答案：

    void swap(int *px,int *py)
    {
        int temp=*px;
        *px=*py;
        *py=temp;
    }
嗯，非常不错！那我们再来做做这个题：

    下面这个swap函数能否用来进行值交换？
    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        py = p;
    }
关于这个题的答案有两种看法：
* 可以交换，因为用指针是可以的
* 不能交换
是骡子是马，拉出来遛遛！我们来实践出真知：

    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        py = p;
    }
    int main(int argc,char *argv[])
    {
        int a=3,b=5;
        printf("Before swap:%d %d\n",a,b);
	    swap(&a,&b);
	    printf("After swap:%d %d\n",a,b);
	    return 0;
    }
编译运行，输出结果为：
    Before swap:3 5
    After swap:3 5

结果是不能交换，不是用了指针么，为什么会是这样的结果？？



这得从C语言的函数调用机制说起。

### 程序的运行
首先，我们需要知道的是，程序是怎么运行的？  
从底层角度来看：我们将源代码经过编译链接阶段生成二进制可执行文件，即bin文件。单片机系统则是下载到片内flash中，上电启动程序(在操作系统中运行这个可执行文件)，先是将文件加载到内存中，然后CPU从内存中读取指令到内部寄存器，再操作内部寄存器中的数据，执行完成之后将内部寄存器中的值写回内存，外设寄存器映射到相应的内存地址中，当需要操作硬件外设时，就对外设映射地址上的数据进行操作，如GPIO/I2C/SPI/TIMER等等。(这只是大概流程，具体实现会更复杂，这里不过多描述)，其实CPU的运行就是对数据的处理过程。
从程序代码的角度来看：一般情况下，程序从main()函数开始(main()是开发者可见的程序入口，但事实上main()函数也是被系统调用的一个函数，这里不再赘述)，程序按顺序执行，当遇到函数调用时，执行被调用函数，等被调用函数执行完毕(递归调用通常是存在的)，函数返回，继续执行main()函数，直到程序结束(而在操作系统中是进程结束)。


### 函数调用的过程
#### 栈
即使是现在的MCU，内部寄存器的资源也是极其有限，以目前非常流行的Cortex M3为例，15个内部寄存器，除去三个特殊寄存器(SP,PC,LR),共有12个通用寄存器，由于是32bit MCU，所以即使在极限状态下，寄存器也只能存几十个字节的数据。所以一旦出现函数调用时，需要保存当前数据和状态，内部寄存器是完全不够用的。    
而栈就是从专门内存中开辟出来用于保存程序运行时状态的内存结构。  
很多朋友对栈并不陌生，知道这是一种先进后出的数据结构，就像我们堆货物，后来的放在上面，取得时候也是先取最上层的。  
这里所说的栈不是数据结构，但是它也是遵循这个原理的内存实现。  
#### 实参和形参
我们都知道函数是带有参数的，在函数定义和声明时，这时候指定的参数叫形参，即形式参数，是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数.在调用函数时，实参将赋值给形参。而在真正函数调用的时候，传入的参数叫实参，即实际参数，实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。
#### 函数调用时栈的状态
首先，我们继续看上面那份代码：

    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        py = p;
    }
    int main(int argc,char *argv[])
    {
        int a=3,b=5;
	    swap(&a,&b);
	    return 0;
    }
在上述代码中，我们可以看到，在main()函数中调用了swap()函数，我们来看看在这个执行过程中发生了什么？
1. 系统将参数压栈，压栈顺序为从右到左，即第一个参数最后压栈，默认情况下，当参数数量少时，参数并不会放如栈中，而是直接通过寄存器传递，这样可以提高运行效率。但是在一般的情况下，我们视为参数是压栈的。即使是寄存器传递参数，传递参数的顺序跟栈一样的从右至左。
2. 系统将函数返回地址压栈，以便程序执行完之后返回到调用前状态。
3. 系统为被调用函数的局部变量分配内存空间
4. 如果出现函数的嵌套调用，重复1-3过程
5. 函数执行结束，如果有返回值，将返回值放入寄存器(如果返回值size太大，则放在内存)
6. 读取栈上返回地址，函数返回。
这就是整个函数调用过程(这只是与参数返回值相关的调用结构，实际的实现要复杂得多，会涉及到数据对齐、上下文的保存等具体问题)。  
#### 再回到swap函数的结果
让我们来看看上述函数调用过程中的第三步，即系统在栈上为局部变量(包括形参)分配地址空间，将寄存器中实参的值传递给形参。所以，从这里我们可以知道，形参和实参是两个地址独立的变量，参数传递时事实上是变量值的传递，即传值。  
很多人提到参数传递有传值和传址两种方式，但是事实上传址是传值的其中一种形式，本质上传址传的是指针变量的值(即地址值)，也是一种值传递，所以严格来说是没有传址和传值的区分的。  
需要声明的是，指针是一种数据类型,int*,char*等等，和int,char是同一个概念，
而类似

    int *p,
    char* str
和

    int i
    char c
是同一种行为，所以这里的p，str事实上是变量，只不过变量的值是地址。而不是某些书上说的"指针就是地址"，搞清这个问题才能对指针有更清晰的了解。  
##### 我们回过头来看第一个swap函数为什么不能交换：

    void swap(int x,int y)
    {
        int temp=x;
        x=y;
        y=temp;
    }
我们调用这个函数，例如：

    int a=3,b=5;
    swap(a,b)
经过上面的讨论，我们知道，系统在栈上给形参x，y分配了内存空间，然后将a的值赋值给x，b的值赋值给y，相当于进行了这样的操作：

    x=a=3;
    y=b=5;
在函数执行的过程中，x与y成功进行了swap交换，即函数执行完，结果是这样的：

    x:5
    y:3
但是根据我们列出的函数调用过程的第6点可以看到，在函数运行完之后，x和y被销毁，这次x，y的交换行为根本没有意义，因为a，b根本没有参与到函数执行中来。  
##### 那为什么第二个函数就可以交换成功呢？
 
    void swap(int *px,int *py)
    {
        int temp=*px;
        *px=*py;
        *py=temp;
    }
我们依旧调用这个函数：
    
    int a=3,b=5;
    //我们假设a的地址为0x1000，b的地址为0x1004
    swap(&a,&b);
在这次调用中，系统为px，py分配空间(px和py为指针类型)，然后将a，b的地址赋值给px，py，相当于执行了这样的操作：

    px=&a=0x1000;
    py=&b=0x1004;
接下来的三行代码：

    int temp=*px;
    *px=*py;
    *py=temp;
用通俗的语言描述就是：

    系统取出px的值即0x1000，找到地址0x1000上存储的变量，即a，将a赋值给temp,同temp=a;
    系统取出py的值即0x1004，找到地址0x1004上存储的变量，即b，再取出px的值即0x1000，找到0x1000上存储的变量，即a，将b赋值给a,同a=b。
    系统取出temp的值即原a的值，取出py的值即0x1004，找到地址0x1004上存储的变量即b，将temp的值赋值给b，同b=temp。
    函数结束，px，py被销毁,此时a,b的值已进行交换。

##### 那我们再来看看第三个swap函数为什么不能成功交换。

    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        py = p;
    }
我们还是调用这个函数，来一步步地分析：

    int a=3,b=5;
    //我们假设a的地址为0x1000，b的地址为0x1004
    swap(&a,&b);
接下来的三行代码：

    p = px;
    px = py;
    py = p;
用通俗的语言表达就是：
    系统取出px的值即0x1000，将px的值赋值给p，此时p=0x1000;
    系统取出py的值即0x1004，将py的值赋值给px,此时px=0x1004；
    将p赋值给px，即px=0x1000；
    函数结束，px，py被销毁，此时a,b的值不受任何影响。
看到这里，我想你应该看出答案了，这个swap和第一个swap实现其实就是换汤不换药，仅仅是将形参进行了互换，而a，b没受到任何影响。  
由此可见，这种参数传递问题根本就不能以是否是指针这种死板的方式来判断是否有效。  
#### 思考
我想大家都应该已经懂了参数传递的原理，我来出个小题来验证一下：

    请问，下面的释放动态内存的函数有什么问题？
    void myFree(char *ptr){     //ptr为指向动态内存的指针
        free(ptr);
        ptr=NULL;
        return;
    }
欢迎大家留言讨论。
***


### 可变参数函数原理
在上面提到了，在参数压栈的过程中，是从右到左的顺序，即最后一个参数最先压栈。   
printf()函数就是可变参数函数的一员，用过printf的盆友都知道，printf()并不固定参数的个数，pritnf()函数原型为：
    
    int printf( const char* format , ... );
虽说是可变参数，但也并不是完全自由的，对于任意的可变参数函数，至少需要指定一个参数，通常这个参数包含对传入参数的描述(下面会提到原因)。  
可变参数的实现依赖下列几个库函数(宏定义)的定义：

    va_list           //这是一个特殊的指针类型，指代栈中参数的开始
    va_start(ap,T)    //ap为va_list类型，T为函数第一个参数
    va_args(ap,A)     //ap为va_list类型，A为需要取出的参数类型，如int，char
    va_end(ap)        //ap为va_list类型。
接下来我们便动手实现一个可变参数函数add(),返回所有传入的int型参数之和：

    int add(int cnt, ... )
    {
        int sum=0;
        va_list args;
        va_start(args,cnt);
        for(int i=0;i<cnt;i++)
        {
            sum += va_arg(args,int);
        }
        va_end(args);
        return sum;
    }
    int main()
    {
        
        printf("%d\r\n",add(4,1,2,3,4));
        return 0;
    }
程序输出结果：

    10

老规矩，看完示例我们来探究一下示例实现的原理：
* va_list args;这一条语句即定义一个va_list类型(可以看成是一种特殊的指针类型)的变量args，args变量指向的对象是栈上的数据。
* va_start(args,cnt);这一条语句是初始化args，args指向第一个被压栈的参数，即函数的最后一个参数，而cnt则是栈上最后一个参数，系统由此确定栈上参数内存的范围。
* va_arg(args,int); 这个函数需要传入两个参数，一个是指向栈上参数的指针args，这个指针每取出一个数据移动一次，总是指向栈上第一个未取出的参数，int指代需要取出参数的类型。
* va_end(args);当args使用完之后，要将args置为空。
整个函数实现的过程就是我们不需要通过形参来获取实参的值，而是直接从栈上将一个个参数取出来。

在这里，我们需要关注几个问题：
1. 压栈顺序从右往左是怎样实现可变参数传递的？
2. printf()函数和上述的add()实现都在可变参数前至少提供了一个具体参数，可不可以省略这个参数呢？
3. 在使用va_arg()取出函数的值时需要指定类型，如果指定一个错误的类型会怎么样呢？
 
第一和第二个问题其实可以同时来解释，参数从右往左压栈，在可变参函数调用时，先将最后一个参数入栈，最后将第一次参数入栈，可变参数主要是通过第一个参数来确定参数列表，但是这时候如果第一个参数没有被指定的话，编译器将无法定位参数在栈上的范围。  
同时，如果可变参数函数在定义时没有第一个参数的话，编译器直接报错。(gcc)


