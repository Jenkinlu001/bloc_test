## C/C++的函数调用模式
### C语言的经典swap问题
在学习C语言的时候，我们大都遇到过一些经典例题，这些经典例题背后所代表的是往往是C/C++背后的一些运行原理，比如下面这个示例：

    请问下面这个swap()函数能否用来进行值交换?
    void swap(int x,int y)
    {
        int temp=x;
        x=y;
        y=temp;
    }
稍微有些经验的程序员肯定要脱口而出：不行！！  
为什么不行呢？  
这个题我都看过十遍了，因为要用指针！！  
好吧，确实是要用指针，估计十个人有九个能写出标准答案：

    void swap(int *px,int *py)
    {
        int temp=*px;
        *px=*py;
        *py=temp;
    }
嗯，非常不错！那我们再来做做这个题：

    下面这个swap函数能否用来进行值交换？
    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        px = p;
    }
到这里，基本上就会有两个声音：
* 可以交换，因为用指针是可以的
* 不能交换
是骡子是马，拉出来遛遛！我们来实践出真知：

    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        px = p;
    }
    int main(int argc,char *argv[])
    {
        int a=3,b=5;
        printf("Before swap:%d %d\n",a,b);
	    swap(&a,&b);
	    printf("After swap:%d %d\n",a,b);
	    return 0;
    }
编译运行，输出结果为：
    Before swap:3 5
    After swap:3 5

结果是不能交换，不是用了指针么，为什么会是这样的结果？  
这得从C语言的函数调用机制说起。

### 程序的运行
首先，我们需要知道的是，程序是怎么运行的？  
我们将源代码经过编译链接阶段生成二进制可执行文件，即bin文件。在操作系统中运行这个可执行文件时(单片机系统则是下载到片内flash中，按下reset键启动程序)，先是将文件加载到内存中，然后CPU从内存中读取指令到片内寄存器，再操作寄存器中的数据，执行完成之后将寄存器中的值写回内存(这只是大概流程，具体实现会更复杂，这里不过多描述)，其实CPU的运行就是对数据的处理过程。  
但是，寄存器的数量有限，拿cortex M3系列MCU来说，15个片内寄存器，12个通用的32位寄存器，也就是说在最极限的情况下寄存器只能存12*4=48个字节数据，早期的单片机寄存器数量更少，所以在早期的单片机中甚至不支持函数调用(当然那时候也没有C语言)。
后来计算机前辈们提出了在内存中开辟一个来专门支持保存程序运行中间过程的存储空间，这一部分就是今天的主角--栈。


### 函数调用的过程
很多朋友对栈并不陌生，知道这是一种先进后出的数据结构，就像我们堆货物，后来的放在上面，取得时候也是先取最上层的。这里所说的栈不是数据结构，但是它也是遵循这个原理的内存实现。
首先，我们继续看上面那份代码：

    void swap(int *px,int *py)
    {
        int *p;
        p = px;
        px = py;
        px = p;
    }
    int main(int argc,char *argv[])
    {
        int a=3,b=5;
        printf("Before swap:%d %d\n",a,b);
	    swap(&a,&b);
	    printf("After swap:%d %d\n",a,b);
	    return 0;
    }
在上述代码中，我们可以看到，在main()函数中调用了swap()函数，我们来看看在这个过程中发生了什么？
1. CPU将函数返回地址压栈。
2. CPU在栈上为被调用函数的参数分配地址空间
3. CPU为被调用函数的局部变量分配内存空间
4. 如果出现函数的嵌套调用，重复1-3过程
5. 函数执行结束，如果有返回值，将返回值放入寄存器(如果返回值size太大，则放在内存)
6. 将栈上数据一个个弹出，销毁栈上数据，注意这里的销毁并非为真正的销毁，只是不再去管它，并不会置零或者置1,这也是为什么局部变量未初始化时的值不确定，因为它的值就是上一次执行栈中的值。
7. 取出返回地址，将返回地址装入PC指针(程序计数器，指向下一条将要执行的指令地址)，函数返回。
8. 如果被调用函数有返回值，取回返回值，继续执行函数。
这就是整个函数调用过程(这是基础实现，部分具体实现会加入一些其他信息)。
