##### 或许你以为这一章到这里就结束了，不！！！这还只是个开始，在上面我们剖析swap()函数实现时提到了一些关于函数调用时栈的活动，接下来我们要详细地讨论一下栈实现的细节部分。

### 细说函数调用
#### 栈帧结构
在经典操作系统中，栈总是向下生长的，向下生长意味着由高地址向低地址延伸，当数据压栈时，栈向低地址延伸，当从栈中弹出数据时，栈缩回高地址。  
在这里我们需要了解到一个概念，栈帧结构(可以通俗翻译为堆栈活动记录)，这个结构涉及到两个内部寄存器：esp和ebp。
#### esp和ebp
在经典X86系统中，esp指向栈顶，而ebp指向当前调用函数的栈底(注意是当前调用函数而不是整个栈的栈底),由ebp指针进行栈上的参数寻址。
我们来分析函数调用时栈活动记录的细节：
首先，还是准备一个简单的函数：

    int firstFunc(int x,int y){
        return x+y;}

    int main(){
        int c=firstFunc(3,5);
        return 1;
    }
它所对应的函数调用时栈活动是这样的：

光贴出这么一张图，估计很多朋友是懵逼的，下面我们就来解释一下。  
* 在main()函数调用firstFunc()之前，ebp指向main()函数的基地址，而在调用firstFunc()时，ebp指向新函数的栈基地址，即指向firstFunc()函数基地址，此时ebp为firstFunc()函数的栈底，但是栈底之上的第一次四字节就是放的main()函数的栈底指针。

* esp则一直指向当前函数栈顶，当发生函数调用时，直接将用ebp替代esp指向当前函数栈顶即被调用函数的栈基地址。

* 当函数返回时，由于ebp的指向部分的第一个元素为旧ebp，所以直接用旧ebp赋值给ebp即可，esp则返回到ebp的位置(因为在函数调用时，将esp的值赋值给了ebp，这里返回到函数调用之前的状态)。  

既然是底层分析，那么就不能空口无凭，我们来一段硬货：上反汇编代码：
编译上述的代码文件，然后用objdump指令进行反汇编，将结果重定向到文件：

    gcc -g test.c -o test
    objdump -S test > test.file
注意这里的编译需要添加 -g 参数，那为什么要用反汇编而不是直接用gcc 的-E指令生成汇编指令呢？  
因为直接编译生成的汇编指令是纯汇编指令，晦涩难懂，但是经过objdump反汇编出来的代码嵌入了源代码，更方便对照。  
下面是部分结果：***注意由于平台原因，这里的栈帧是rbp和rsp，而不是早期的ebp和esp。***

    int firstFunc(int x,int y)
    {
    4004d6:	55                   	push   %rbp               //将rbp的值压栈
    4004d7:	48 89 e5             	mov    %rsp,%rbp          //将rsp的值赋值给rbp
    4004da:	89 7d fc             	mov    %edi,-0x4(%rbp)    //将edi寄存器中的值放在rbp-4的位置，即压栈(压栈时向低地址延伸)
    4004dd:	89 75 f8             	mov    %esi,-0x8(%rbp)    //将esi寄存器中的值放在rbp-8的位置。
        return x+y;
    4004e0:	8b 55 fc             	mov    -0x4(%rbp),%edx    //将rbp-4位置的值放入edx寄存器
    4004e3:	8b 45 f8             	mov    -0x8(%rbp),%eax    //将rbp-8位置的值放入eax寄存器
    4004e6:	01 d0                	add    %edx,%eax          //将edx寄存器的值 + eax寄存器中的中，结果放在eax中，作为返回值
    }
    4004e8:	5d                   	pop    %rbp               //函数即将返回，将rbp还原(rbp指向的首地址出存放的是调用函数的rbp栈基地址)
    4004e9:	c3                   	retq                      //返回

    00000000004004ea <main>:
    int main()
    {
    4004ea:	55                   	push   %rbp
    4004eb:	48 89 e5             	mov    %rsp,%rbp
    4004ee:	48 83 ec 10          	sub    $0x10,%rsp             //为函数的执行分配内存空间
        //int a=3,b=5;
        int c=firstFunc(3,5);
    4004f2:	be 05 00 00 00       	mov    $0x5,%esi             //将实参5放入寄存器esi中
    4004f7:	bf 03 00 00 00       	mov    $0x3,%edi             //将实参3放入寄存器edi中
    4004fc:	e8 d5 ff ff ff       	callq  4004d6 <firstFunc>    //执行函数
    400501:	89 45 fc             	mov    %eax,-0x4(%rbp)       //将eax的值取出来，因为调用了firstFunc，eax中存的是返回值，这里是读出返回值。
        return 1;
    400504:	b8 01 00 00 00       	mov    $0x1,%eax             //将返回值1放入eax寄存器
    }
反汇编出来的是AT&T格式的汇编代码，如果不懂汇编代码的直接看我添加的注释部分。
从上面的汇编代码可以看出，其实平常我们在书上看到的一些关于函数调用时栈的活动并没有我们看到得那么简单，主要是以下几点：
* 当实参数量较少时，参数直接由寄存器来传递，博主在X86平台上的测试结果为：默认情况下，参数少于6个时，直接在栈上传参，当参数多于六个时，才将多余的部分放在栈中。这个过程可以通过gcc编译选项配置是否优先使用寄存器，
* 函数的返回值被记录在寄存器中，然后由调用者从寄存器中取，但是当返回值占用空间太多时(如结构体)，将会存在内存中，由调用者从内存中获取。
    * 有兴趣的朋友可以想一想，为什么不是存在栈上面呢？答案是：如果返回一个局部变量的值(注意这个变量占用很多内存，就像结构体，无法放在寄存器中)，它是会把这个返回值放在栈上的，
* 传输传递的过程中，参数的传递过程是从右到左的顺序



![参考](https://www.zhihu.com/question/22444939)  