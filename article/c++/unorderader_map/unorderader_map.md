# C++ STL 哈希表之 Unorderader map
在日常的编程中，我们经常会用到数组和链表，这是两个应用最为广泛的数据结构。
数组可以直接通过下标访问元素，时间复杂度为O（1），但是由于其长度固定的特点，数组占用的内存空间无法伸缩，往往会造成内存空间的浪费。
链表则是在堆上分配内存，使用完之后可以立马释放，而且程序员分配的内存大小可以自由控制，在空间上可以做到非常高效率的利用，但是由于分配的内存空间是系统临时指定的，所以访问时只好以轮询的方式，所以增加了程序的时间复杂度。
## 学生资料的统计
我们不妨从一个简单的问题入手：

    有一个学生组织共有50人，请记录组织中成员的信息(信息包含姓名、年龄等等)
只要有过编程经验的朋友都知道，这是一道送分题，用最简单的数组或者链表就可以解决。
#### 数组
首先，定义一个结构体来保存每个成员的信息：

    struct Student
    {
        char *name;
        unsigned char age;
        ...
    }；
然后定义一个数组

    struct Student stus[50];

#### 链表
而链表的操作也是很简单的：
同样定义一个结构体来保存每个学生的信息：

    struct Student
    {
        char *name;
        unsigned char age;
        ...
    }；
然后定义每一个学生的信息作为一个链表节点

    typedef struct Stu 
    {
        struct Stu *next;
        struct Student stuInfo;
    }ListNode;
设置一个链表头，每添加一个学生的信息时，就申请一片动态内存。

    ListNode *new_stu = new ListNode;
然后将新同学的信息插入到学生链表中，这样就实现了数据的存储。

### 上述实现的比较
* 从实现难度上来说：数组要优于链表结构，链表需要处理内存的申请释放，而且还要处理申请失败的情况，而数组则不需要考虑这些问题。
* 从查找速度上来说：数组直接通过下标访问，时间复杂度为O(1),而链表需要遍历每一个节点，时间复杂度为O(n),在查找速度上数组优于链表
* 从写入操作上来说：这里的写入操作指的是增删改，链表的优势在于每个节点之间由指针连接，可以自由的打乱重组，删除中间节点仅需要三步操作：
    * del_node = pre_stu->next;   //取出将被删除节点
    * pre_stu->next = pre_stu->next->next;  //将被删除节点上一节点指向被删除节点下一节点
    * delete del_node;   //删除节点 
    而数组删除一个中间节点，如果想要数组连续，则需要将后续节点全部往前移，在这种情况下在时间上的效率非常低，或者不改动数组其他部分，这个空下来的部分由下一个新增的成员补充，但是这样也将打乱排序，增加操作上的成本。所以在写入操作上，链表要优于数组。
* 在空间的利用效率上来说：全局或者静态数组定义之后便占用了固定的内存空间，且内存空间是连续的。这样的情况下就导致这片内存空间只能为数组服务，而且在不确定目标成员大小时，往往定义的数组大小为成员数的最大值，这样就导致这一片内存空间无法重复利用，造成空间的浪费。而链表则不同，链表遵循用多少申请多少，用完即释放的原则，而且申请的内存不必连续，可以将一片内存重复地使用。所以在空间的使用效率上链表要优于数组  
* 从扩展性上来说：普通数组不支持扩展，链表有良好的扩展性。

看到这里，读者们可以发现，其实数组和链表是两种在内存形式上表示不同的数据结构，并没有好坏之分，部分C/C++程序员特别钟意使用数组而不喜欢使用链表，最主要的因素是两个：
* 链表的实现以及差错控制相对麻烦，容易出错，而数组使用相对简单很多。
* 大多数的软件设计中并没有对软件质量做严格的要求或者使用数组代替链表带来的损失极小。例如在一个内存为256K，执行频率为500Mhz的芯片中跑一个程序，某一个模块使用链表可以节省500 Bytes空间，加快运行速度1ms，但是这个模块在程序中被调用次数并不多，像这种情况下，使用数组和使用链表带来的直观感受是没有差别。  
但是我觉得，作为一个程序员，不应该仅仅对项目的完成负责，当不用对代码的运行效率负责时，我们也应该对项目中代码的复用、调试、维护负责，使用更合适、更规范的代码，甚至不断追求完美才是一个程序员的自我修养。


### 哈希函数的使用
不知道各位有没有注意到一点，尽管我在上面提到了数组来存储学生信息时查询的时间复杂度为0(1)，但是这个是怎么实现的？  
很多朋友就脱口而出，还能怎么实现，用数组下标就可以访问啊。  
但是如果你仔细一推敲，就会发现这个问题没那么简单，在处理学生数据时，我们一般以学号来作为学生的唯一标识，那么问题来了，要在一个庞大的数组内访问一个已知学号的学生信息，这个下标又是多少呢？  
在数据比较少的时候，比如数组中仅有少量学生成员时，我们可以这样定义：

    #define NUM_0000   0
    #define NUM_0003   1
    #define NUM_00081  2
    ....
然后我们需要访问学号为0003的学生时，直接使用**stus[NUM_0001]**，使用宏定义的方式来直接访问成员，但是这种操作方式仅适用于成员少的情况，如果学生的学号没有规律且数量庞大，那么将要写大量的宏定义，这样明显不符合设计要求。
### 哈希函数
那么，有没有一个更简便的方法来实现唯一识别号与数组下标的映射呢？  
这个东西就是hash函数，又称为散列函数，但是这个hash函数并没有什么统一标准，它的核心思想就是就是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数，这个消息可能是字符、数组、字符串等等，拥有这样的hash存储结构的数据结构称为散列表，或者叫哈希表。但是，问题又来了，数组中的每一个元素空间只能对应存储一个元素，万一两个不同的唯一识别号经过hash计算之后返回同样的数组下标怎么办？这样岂不是有冲突？
所以hash程序实现需要满足以下条件：
* 一个好的hash函数的值应该尽可能地均匀分布
* 为配合hash函数的使用，数组的大小应该满足hash函数的使用场景
设输入为key，输出为value，key可以是整数、字符串等等类型(同时其他类型例如字符串也可以转化成整型,例如将字符串每个元素的ASCII值作计算，但是同样得确保转换后的整型不一致)，我们来看看常用且实现较为简单的hash函数的实现方法：
* 直接定址法：取key的线性函数值作为hash值，value = a * key + b,a,b为常数。这一类散列码的特点是：对输入为整型数据而言，不会产生下标冲突。
* 除留余数法：假设数组的长度为l，value = key % l,这一种散列码实现简单，运用比较多，但是如果输入的元素集合不具有一定的规律，比较容易产生冲突。数组的长度最好是质数。
* 数字分析法：数字分析法即对关键字进行分析，取关键字的若干位进行或者组合进行hash计算，这一类散列码的特点是比较灵活，可根据实际情况来做出调整，例如对一个区的电话号码进行hash散列，这个区都是 1111开头，我们就可以只取后面的数字进行hash计算
* 平方取中法：取关键字平方后中间几位作哈希地址。适于关键字位数不定情况。
* 自定义方法：上述提供的hash函数只是一些参考，事实上在不同的应用场景下可以自定义更合适的hash函数。

## 哈希表冲突
其实，当输入的数据量很大的时候，hash函数输出的冲突是无法避免的，我们不能指望一个hash函数可以完美地为我们解决hash冲突问题。一旦出现hash表的冲突我们应该怎么解决呢？
### 开放寻址法



## 需求升级
在上一个应用场景中，突然情况变了，因为某些原因，这个学生组织人数激增，从50人增加到5000人，而且人数还在不断地变化当中，需要频繁地对成员进行操作。
作为一个程序员，只能微笑着面对需求的变更...
因为需要频繁地进行增删改查操作，且不断地需要动态扩展人数，这时候数组明显不适合当前应用场景。
那我们就使用链表，维护一个5000个节点的链表，但是这样又有一个问题，每一次的增删改查操作的都要遍历整个链表,显然这种情况下的运行速度是不满足要求的。

## 思考
既然数组有访问速度快的特点，链表有支持动态扩展且增删改操作方便的特点，那么

