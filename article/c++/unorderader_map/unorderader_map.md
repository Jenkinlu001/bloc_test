## 哈希表
### 先从数组说起
任何一个程序员，基本上对数组都不会陌生，这个最常用的数据结构，说到它的优点，最明显的就是两点：
* 简单易用，数组的简易操作甚至让大多数程序员依赖上了它，在资源富足的情况下，我们甚至会无意识地忽略其它更适用的数据结构而使用数组(别说你没这么干过..)。
* 查找的快速性，数组中查找元素可以直接通过下标进行定位，速度快。
记得有几次我面试应聘者(谁说两年工作经验的菜菜不能当面试官!!)，总会问到一个基础的问题，数组和链表有什么区别？
他们总能说到这一点：数组查找时间复杂度是O(1)，而普通链表查找元素最坏的情况下需要遍历整个链表。  
再问：那为什么数组查找时间复杂度为O(1)呢？   
回：数组可以用下标来访问啊，心里状态(你怎么这都不知道？)  
接着问：那当你要访问数组内元素时，你怎么知道这个元素对应着哪个索引值？
到这里，就有一部分基础较为薄弱或者编程经验不足的盆友回答不上来。  

是的，我在刚开始写程序的时候，也会经常用到数组，而且往往数组中的元素都是预定义好的，当元素少的时候，常用的做法是使用宏定义来定义下标：

    #define ZHANGSAN  0
    #define LISI      1
    ...
这样，就可以通过ZHANGSAN这个宏定义作为下标访问到"张三"。甚至干脆使用宏定义，直接使用下标访问，写出一些可读性很差的代码。当面对一长串的宏定义时，我们就产生了一种数组就是这么使用的错觉。  
但是，如果数组内的元素是预先不知情的，或者数量庞大呢？宏定义这种做法明显不再合适了。比如要存储学生相关信息时，便使用结构体数组，在查找时就轮询每一个结构体中"学号"字段，来判断是否命中。在这种情况下，数组就完全失去了快速查找的优势。

### hash函数的使用
其实，在上述情况中，我们需要解决的问题就是建立 "元素和数组下标" 之间的映射关系，hash函数就担任了这么一个角色(但是hash函数并不仅仅在hash表中使用)。

#### 定义
hash函数，又称为散列函数，但是这个hash函数并没有什么统一标准，它的核心思想就是就是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数，这个消息可能是字符、数组、字符串等等，拥有这样的hash存储结构的数据结构称为散列表，或者叫哈希表。

### 示例
定义总是臭又长，我们来举个例子：有100个学生，我们需要用一个容量为100的数组来存下他们的信息，使用他们的名字来进行hash计算，输出0-99的下标值，我们可以这样，我们可以尝试定义这样一个最简单的hash函数：
    int hash_func(char* name)
    {
        sum = name中每个字符相加
        返回 sum%100
    }
这是个非常简单的hash函数实现，每个名称都会对应返回0-99的数组下标。  
但是细心的朋友肯定能发现其中的问题：这个函数并不能保证每个name计算出来的值都不一样，100个学生刚好填满数组，而且还不考虑重名的情况，如果两个名字计算出来的hash值相同，这就产生了冲突，毕竟一个坑只能放一个萝卜。很显然，这是个"很烂"的hash函数。(事实上我们并不能撇开应用场景来单纯地判断一个hash函数的好坏，在某些情况下，线性映射能达到很好的效果，而某些情况下需要更复杂的hash函数)。

### hash函数的要求
那么，一个hash函数需要满足什么要求呢？
1. 接受一个单一的参数，这个参数可以是任何类型，但是只能是一个
2. 返回一个整型值(一般情况下)
3. 不抛出异常
4. 对于两个相同的输入，输出必须相同
5. 对于两个不同的输入，输出相同的概率需要做到非常小。
6. hash的计算不能过于复杂，时间复杂度尽可能地低。
***
### 常用的hash函数
既然自己想不到比较好的hash算法，我们就来看看别人是怎么做的吧，下面是一些常用的hash算法：

####  直接定址法
取key的线性函数值作为hash值，value = a * key + b,a,b为常数。这一类散列码的特点是：对输入为整型数据而言，不会产生下标冲突。不产生冲突当然是最完美的状态，但是这种方式要求输入的key遵循一定的线性规律。

#### 除留余数法
除留余数法：假设数组的长度为l，value = key % l,这一种散列码实现简单，运用比较多，但是如果输入的元素集合不具有一定的规律，比较容易产生冲突。数组的长度最好是质数，被除数为质数在一定程度上可以缓解数据堆积的问题。

#### 数字分析法
数字分析法即对关键字进行分析，取关键字的若干位进行或者组合进行hash计算，这一类散列码的特点是比较灵活，通常是结合其他hash函数来计算，可根据实际情况来做出调整，具有想当的灵活性。

#### 平方取中法
取关键字平方后中间几位作哈希地址。适于关键字长度不统一的情况，而且对于元素连续的输入，可以很好的将其散列均匀，而且相对于除法而言，乘法的执行速度更快，这个由硬件决定。

###处理冲突的方法
从hash函数的要求可以看到，事实上我们只能定义对于两个不同的输入，输出相同的概率尽可能小，而不能做到完全杜绝冲突，所以我们必须提前想好处理冲突的措施。  
#### 开放地址法
开放地址法是比较常用的处理冲突算法之一，通常分为几种：
1. 线性探测：当需要插入的元素发现与已有元素下标冲突时，就依次往后遍历，直到找到一个空槽，这时候将元素插入进去，由此可以看出，插入的操作非常简单。但是如果我要查找一个元素时，将Key经过hash运算之后得到的hash值作为下标找到的不一定是对应的元素(因为插入时的冲突导致往后移)，这时候有几种处理方案：
    * 在只增不删的hash表中，从计算出的hash下标处往后一个一个进行对比(对比函数就是用的key_equal()函数)，直到找到元素或者找到一个空槽表示未找到，因为冲突时都是往后一个槽一个槽地找。
    * 在可删除的hash表中，删除一个槽时，会导致中间有空槽存在，这个时候查找在插入时遇到冲突的元素的时候，最坏的情况下需要遍历整个hash表，才能确定是否存在。或者在删除时，将之前因冲突而放置在其他槽的元素取回，这里的操作较为复杂。
2. 二次探测：在线性探测的基础上，从依次往后遍历变成按照 +(+1²)，+(2²)，+(3²)，+(4²)的规律进行探测，在线性探测的基础上，可以缓解数据堆积问题，提升效率，操作上一致。
3. 再散列：当产生冲突时，就将key用另一个hash函数计算。

从直觉上来看，上述三种方式处理冲突不够优雅，第一、二种处理方式明显不适合大规模的数据存储，一旦数据规模增大，散列很可能出现多次冲突的情况，查找时的往后遍历所花费的时间是不可接受的，而第三种，需要设计多种hash函数，首先在复杂度上就要提高一个级别，同时，在查找时，我们也不能忽略hash函数的执行带来的时间开销，如果需要进行好几次hash计算，查找效率反而会降低很多。

同时，如果涉及到数据规模的增大，当面临几十上百K的数据规模时，因为数组的不可扩展性，我们在刚开始就得定义一个足够大的数组以满足需求，又或者涉及到动态增长，这种存储方式对空间的浪费是非常严重的。  
鉴于数组的不可扩展，内存连续的属性，这种hash表并不能满足大型数据规模的应用场景，对于解决数组空间的浪费以及扩展问题，我们第一反应自然是使用链表！！


### 链地址法
我们都知道链表的缺点是查找速度慢，一般情况下需要遍历链表进行查找，既然数组拥有查找速度快的优点，链表具有可扩展型号，空间利用率高的特点，那有没有一种东西既有数组查找的优点，又能继承链表的动态扩展性呢？  
答案就是hash中的链地址法。



### 再建hash
### 建立公共溢出区







在日常的编程中，我们经常会用到数组和链表，这是两个应用最为广泛的数据结构。
数组可以直接通过下标访问元素，时间复杂度为O（1），但是由于其长度固定的特点，数组占用的内存空间无法伸缩，往往会造成内存空间的浪费。
链表则是在堆上分配内存，使用完之后可以立马释放，而且程序员分配的内存大小可以自由控制，在空间上可以做到非常高效率的利用，但是由于分配的内存空间是系统临时指定的，所以访问时只好以轮询的方式，所以增加了程序的时间复杂度。
## 学生资料的统计
我们不妨从一个简单的问题入手：

    有一个学生组织共有50人，请记录组织中成员的信息(信息包含姓名、年龄等等)
只要有过编程经验的朋友都知道，这是一道送分题，用最简单的数组或者链表就可以解决。
#### 数组
首先，定义一个结构体来保存每个成员的信息：

    struct Student
    {
        char *name;
        unsigned char age;
        ...
    }；
然后定义一个数组

    struct Student stus[50];

#### 链表
而链表的操作也是很简单的：
同样定义一个结构体来保存每个学生的信息：

    struct Student
    {
        char *name;
        unsigned char age;
        ...
    }；
然后定义每一个学生的信息作为一个链表节点

    typedef struct Stu 
    {
        struct Stu *next;
        struct Student stuInfo;
    }ListNode;
设置一个链表头，每添加一个学生的信息时，就申请一片动态内存。

    ListNode *new_stu = new ListNode;
然后将新同学的信息插入到学生链表中，这样就实现了数据的存储。

### 上述实现的比较
* 从实现难度上来说：数组要优于链表结构，链表需要处理内存的申请释放，而且还要处理申请失败的情况，而数组则不需要考虑这些问题。
* 从查找速度上来说：数组直接通过下标访问，时间复杂度为O(1),而链表需要遍历每一个节点，时间复杂度为O(n),在查找速度上数组优于链表
* 从写入操作上来说：这里的写入操作指的是增删改，链表的优势在于每个节点之间由指针连接，可以自由的打乱重组，删除中间节点仅需要三步操作：
    * del_node = pre_stu->next;   //取出将被删除节点
    * pre_stu->next = pre_stu->next->next;  //将被删除节点上一节点指向被删除节点下一节点
    * delete del_node;   //删除节点 
    而数组删除一个中间节点，如果想要数组连续，则需要将后续节点全部往前移，在这种情况下在时间上的效率非常低，或者不改动数组其他部分，这个空下来的部分由下一个新增的成员补充，但是这样也将打乱排序，增加操作上的成本。所以在写入操作上，链表要优于数组。
* 在空间的利用效率上来说：全局或者静态数组定义之后便占用了固定的内存空间，且内存空间是连续的。这样的情况下就导致这片内存空间只能为数组服务，而且在不确定目标成员大小时，往往定义的数组大小为成员数的最大值，这样就导致这一片内存空间无法重复利用，造成空间的浪费。而链表则不同，链表遵循用多少申请多少，用完即释放的原则，而且申请的内存不必连续，可以将一片内存重复地使用。所以在空间的使用效率上链表要优于数组  
* 从扩展性上来说：普通数组不支持扩展，链表有良好的扩展性。

看到这里，读者们可以发现，其实数组和链表是两种在内存形式上表示不同的数据结构，并没有好坏之分，部分C/C++程序员特别钟意使用数组而不喜欢使用链表，最主要的因素是两个：
* 链表的实现以及差错控制相对麻烦，容易出错，而数组使用相对简单很多。
* 大多数的软件设计中并没有对软件质量做严格的要求或者使用数组代替链表带来的损失极小。例如在一个内存为256K，执行频率为500Mhz的芯片中跑一个程序，某一个模块使用链表可以节省500 Bytes空间，加快运行速度1ms，但是这个模块在程序中被调用次数并不多，像这种情况下，使用数组和使用链表带来的直观感受是没有差别。  
但是我觉得，作为一个程序员，不应该仅仅对项目的完成负责，当不用对代码的运行效率负责时，我们也应该对项目中代码的复用、调试、维护负责，使用更合适、更规范的代码，甚至不断追求完美才是一个程序员的自我修养。


### 哈希函数的使用
不知道各位有没有注意到一点，尽管我在上面提到了数组来存储学生信息时查询的时间复杂度为0(1)，但是这个是怎么实现的？  
很多朋友就脱口而出，还能怎么实现，用数组下标就可以访问啊。  
但是如果你仔细一推敲，就会发现这个问题没那么简单，在处理学生数据时，我们一般以学号来作为学生的唯一标识，那么问题来了，要在一个庞大的数组内访问一个已知学号的学生信息，这个下标又是多少呢？  
在数据比较少的时候，比如数组中仅有少量学生成员时，我们可以这样定义：

    #define NUM_0000   0
    #define NUM_0003   1
    #define NUM_00081  2
    ....
然后我们需要访问学号为0003的学生时，直接使用**stus[NUM_0001]**，使用宏定义的方式来直接访问成员，但是这种操作方式仅适用于成员少的情况，如果学生的学号没有规律且数量庞大，那么将要写大量的宏定义，这样明显不符合设计要求。
### 哈希函数
那么，有没有一个更简便的方法来实现唯一识别号与数组下标的映射呢？  
这个东西就是hash函数，又称为散列函数，但是这个hash函数并没有什么统一标准，它的核心思想就是就是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数，这个消息可能是字符、数组、字符串等等，拥有这样的hash存储结构的数据结构称为散列表，或者叫哈希表。但是，问题又来了，数组中的每一个元素空间只能对应存储一个元素，万一两个不同的唯一识别号经过hash计算之后返回同样的数组下标怎么办？这样岂不是有冲突？
所以hash程序实现需要满足以下条件：
* 一个好的hash函数的值应该尽可能地均匀分布
* 为配合hash函数的使用，数组的大小应该满足hash函数的使用场景
设输入为key，输出为value，key可以是整数、字符串等等类型(同时其他类型例如字符串也可以转化成整型,例如将字符串每个元素的ASCII值作计算，但是同样得确保转换后的整型不一致)，我们来看看常用且实现较为简单的hash函数的实现方法：
* 直接定址法：取key的线性函数值作为hash值，value = a * key + b,a,b为常数。这一类散列码的特点是：对输入为整型数据而言，不会产生下标冲突。
* 除留余数法：假设数组的长度为l，value = key % l,这一种散列码实现简单，运用比较多，但是如果输入的元素集合不具有一定的规律，比较容易产生冲突。数组的长度最好是质数。
* 数字分析法：数字分析法即对关键字进行分析，取关键字的若干位进行或者组合进行hash计算，这一类散列码的特点是比较灵活，可根据实际情况来做出调整，例如对一个区的电话号码进行hash散列，这个区都是 1111开头，我们就可以只取后面的数字进行hash计算
* 平方取中法：取关键字平方后中间几位作哈希地址。适于关键字位数不定情况。
* 自定义方法：上述提供的hash函数只是一些参考，事实上在不同的应用场景下可以自定义更合适的hash函数。

## 哈希表冲突
其实，当输入的数据量很大的时候，hash函数输出的冲突是无法避免的，我们不能指望一个hash函数可以完美地为我们解决hash冲突问题。一旦出现hash表的冲突我们应该怎么解决呢？
### 开放寻址法



## 需求升级
在上一个应用场景中，突然情况变了，因为某些原因，这个学生组织人数激增，从50人增加到5000人，而且人数还在不断地变化当中，需要频繁地对成员进行操作。
作为一个程序员，只能微笑着面对需求的变更...
因为需要频繁地进行增删改查操作，且不断地需要动态扩展人数，这时候数组明显不适合当前应用场景。
那我们就使用链表，维护一个5000个节点的链表，但是这样又有一个问题，每一次的增删改查操作的都要遍历整个链表,显然这种情况下的运行速度是不满足要求的。

## 思考
既然数组有访问速度快的特点，链表有支持动态扩展且增删改操作方便的特点，那么

