## python的内存机制
作为一门简单易用的语言，且配备海量的库，python可谓是程序员手中的掌中宝，编程本身就是一种将人类思维转化为计算机思维的技术，如果不需要去追求极致的运行效率同时又不限制于计算机内存空间，python无疑是目前最方便的语言了。  
作为一个合格的程序员，自然是要知其然并知其所以然，除了能够应用python来放飞自我之外，同时也要探究python其内部的运行原理，首当其冲的python编程中必须要用到的变量以及背后的运行机制。
***注：以下示例在linux平台下编写，使用python2.7***
## 引用机制
python的变量-内存模型更像是C++中的引用机制，python中的每个变量不一定占用内存空间，变量更像是一份内存的引用，通过这个变量可以访问到内存中的数据，举个例子：

    a=10
    b=a
    c=[1,2,3,4]
    d=c
    print "%x%x"  %(id(a),id(b))
    print "%x%x"  %(id(c),id(d))
输出结果：

    b51080.b51080
    7f28bf69b758.7f28bf69b758
其中id()是python的系统函数，返回对象的内存起始地址。  
从结果可以看出，a与b，c与d变量对应的地址事实上为同一个地址，也就是当我们使用变量a和b时，使用的是同一个对象，而a,b是这个对象的引用，我们可以通过系统函数sys.getrefcount()来查看一个对象的引用数量：

    import sys
    a=257
    print sys.getrefcount(a)
    b=a
    print sys.getrefcount(a)
输出结果：

    2
    3
显然，这个结果并不在我们的预料当中，由于a和b在同一个地址，结果应该是1、2，为什么是2,3呢？  
这是因为在sys.getrefcount()函数调用时，a作为参数也被引用了一次，所以出现了2、3的结果。

## 缓存小数据机制
上面讲了python变量赋值时的内存机制，事情就这么完美结束了吗？  
并没有！！！  
我们再来看一个例子：

    >>> a=10
    >>> b=10
    >>> print "%x.%x" %(id(a),id(b))
输出结果：

    b51080.b51080
看到这个结果，我缓缓摘下我的眼镜，拿酒精仔仔细细擦了三遍之后再戴上看，没看错！这两个变量还是同一个地址内容的引用，这一次两个变量的初始化是独立的，并非赋值初始化，为什么两个变量还是同一个地址的引用呢？  
答案是：

    在Python中，Python会有一个缓存对象的机制，以便重复使用。当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象，以达到节省资源的目的
原来是这样！！！好神奇的用法，好聪明的操作！！！  
但是仔细一想，这不对吧？如果每个数据都进行缓存，那岂不是对内存空间的极度浪费？还是说内存回收机制会过一段时间回收一次垃圾内存？  
我们再来看下面一个例子：

    >>> a=100
    >>> b=100
    print "%d%d" %(id(a),id(b))
    >>> a=256
    >>> b=256
    print "%d%d" %(id(a),id(b))
    >>> a=257 
    >>> b=257
    print "%d%d" %(id(a),id(b))
输出结果：

    5223836.5223836
    5225932.5225932
    5241840.5241864
从结果来看，当a小于256时，这个值会被系统缓存循环利用，而当a>256时，系统并不会进行缓存(当然不仅仅是三次实验的结果，博主后续还试了很多值，就不一一列出了)  
我们来用另一种方法来验证这个问题，即sys.getrefcount()：

    import sys
    a=10
    print sys.getrefcount(a)
    a=257
    print sys.getrefcount(a)
输出结果为：

    15
    2
结果显而易见，10这个值被系统缓存，且在别处引用了多次，而257这个值为2(为什么为2而不是1在上面有解释)  
那么问题又来了，如果是其他类型的数据呢？我们接着看

    a="downey"
    b="downey"
    print "%d%d" %(id(a),id(b))
结果为：

    39422528.39422528
短字符串也会有缓存机制  
然后是list：

    a=[1,2,3]
    b=[1,2,3]
    print "%d%d" %(id(a),id(b))
    39704576.39745176
list并没有缓存机制，从这里可以看出，python的缓存机制并不针对所有变量类型
（整个测试过程就不一一列举了，直接上结论！）
### 变量缓存结论
根据各种实验以及多方查证，结果表明：
1、***python的变量其实是一种堆内存的引用，可以理解为一个实体的标签，而在不同变量之间的拷贝复制(如a=b)，他们所表示的对象实体是同一个***
2、***python会对0-256(包括256)的整型数据和短字符串进行缓存以节省多次分配销毁的开销***

好了，关于python变量内存机制的问题就到此为止了，如果朋友们对于这个有什么疑问或者发现有文章中有什么错误，欢迎留言

***原创博客，转载请注明出处！***

祝各位早日实现项目丛中过，bug不沾身.
（完）