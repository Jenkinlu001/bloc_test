## python的内存机制
作为一门简单易用的语言，且配备海量的库，python可谓是程序员手中的掌中宝，编程本身就是一种将人类思维转化为计算机思维的技术，如果不需要去追求极致的运行效率同时又不限制于计算机内存空间，python无疑是目前最方便的语言了。  
作为一个合格的程序员，自然是要知其然并知其所以然，除了能够应用python来放飞自我之外，同时也要探究python其内部的运行原理，首当其冲的python编程中必须要用到的变量以及背后的运行机制。
## 引用机制
python的变量-内存模型更像是C++中的引用机制，python中的每个变量不一定占用内存空间，变量更像是一份内存的引用，通过这个变量可以访问到内存中的数据，举个例子：

    a=10
    b=a
    c=[1,2,3,4]
    d=c
    print "%x%x%x%x"  %id(a) %id(b) %id(c) %id(d)
输出结果：

    b51080.b51080.7f28bf69b758.7f28bf69b758
其中id()是python的系统函数，返回对象的内存起始地址。  
从结果可以看出，a与b，c与d变量对应的地址事实上为同一个地址，也就是当我们使用变量a和b时，使用的是同一个对象，而a,b是这个对象的引用，我们可以通过系统函数sys.getrefcount()来查看一个对象的引用数量：

    import sys
    a=257
    print sys.getrefcount(a)
    b=a
    print sys.getrefcount(a)
输出结果：

    2
    3
显然，这个结果并不在我们的预料当中，由于a和b在同一个地址，结果应该是1、2，为什么是2,3呢？  
这是因为在sys.getrefcount()函数调用时，a作为参数也被引用了一次，所以出现了2、3的结果。

## 缓存小数据机制
上面讲了python变量赋值时的内存机制，事情就这么完美结束了吗？  
并没有！！！  
我们再来看一个例子：

    >>> a=10
    >>> b=10
    >>> print "%x.%x" %(id(a),id(b))
输出结果：

    b51080.b51080
看到这个结果，我缓缓摘下我的眼镜，拿酒精仔仔细细擦了三遍之后再戴上看，没看错！这两个变量还是同一个地址内容的引用，这一次两个变量的初始化是独立的，并非赋值初始化，为什么两个变量还是同一个地址的引用呢？  
答案是：

    在Python中，Python会有一个缓存对象的机制，以便重复使用。当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象，以达到节省资源的目的
原来是这样！！！好神奇的用法，好聪明的操作！！！  
但是仔细一想，这不对吧？如果每个数据都进行缓存，那岂不是对内存空间的极度浪费？还是说内存机制中定义过一段时间回收一次？
