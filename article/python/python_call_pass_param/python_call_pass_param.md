# python函数调用时参数调用方式
## C/C++参数传递方式 
对于C程序员来说，我们都知道C在函数调用时，采用的是值传递，即形参和实参分配不同的内存地址，在调用时将实参的值传给实参，在这种情况下，在函数内修改形参并不会影响到实参，但是这样带来一个问题，如果我们需要刻意地对实参进行修改，就不得不传递实参的指针到函数，然后在函数中修改指针指向的数据，以达到修改实参的目的。  
后来，C++中引入了引用这个概念，即在函数定义时，在形参前加一个&符号，表示传递参数的引用，在写法上，除了多出一个&符号，其他部分和C中传值调用一样，但是实际确是达到了可以在函数内修改实参内容的目的。这种参数传递的方式被称为传引用。

## python的参数传递
说完了C/C++的参数传递方式，那么python中参数传递到底是传值还是传引用呢？我们来看两个实例：
test1.py:

    def test(num):
        num += 10
    x = 1
    test(x)
    print x
输出结果：
    
    1
test2.py:
    def test(lst):
        lst[0] = 4
        lst[1] = 5
    tlist = [1,2]
    test(tlist)
    print tlist
输出结果：
    [4,5]

可以看到，在上述代码test1.py中，在函数中修改传入的x的值，函数执行完之后，x并没有改变，至少对于int型变量而言，python函数调用为传值。  
在代码test2.py中，在函数中修改传入的tlist的值，函数执行完，list的内容却被函数修改了，从这里又可以看出，对于list类型而言，python函数调用为传引用。    
看到这里就很疑惑了，python的函数调用到底是传值还是传引用？

### python的变量内存模型
要搞清楚python的函数调用时传值还是传引用，这还得从python的变量内存模型说起，作为一个C/C++程序员，对于变量的理解就是CPU会为每个变量分配独立的内存空间，在变量生存周期结束时内存空间被收回。但python却使用了另一种完全不同的机制，对于python而言，一切皆对象，python为每个对象分配内存空间，但是并非为每个变量分配内存空间，因为在python中，变量更像是一个标签，就像在现实生活中，一个人可以有多种身份标签，比如：XX的父亲，XX的儿子，XX的工程师，X地志愿者等等，但对应的实体都是同一个人，只占同一份资源。  
为了验证这个问题，我们可以做下面的实验：

    x = 1
    print(id(x))
    print(id(1))
    print(id(5))
    x= 5 
    print(id(x))
    print(id(1))
    print(id(5))
输出：
    166656176
    166656176
    166656128

    166656128
    166656176
    166656128
从输出可以看出，当我们将x变量的值由1变成5时，x的地址刚好从对象1的内存地址变成了对象5的内存地址。  

    Tips：
        对于C/C++程序员来说，这段代码并不好理解，变量的值被改变时，竟然是变量的地址变化而不是原变量地址上的值变化！而且，为什么系统会为字面值1和5分配内存空间，这在C/C++中是不存在的！
        所以我们要从python变量内存角度来理解：对象1和对象5早就在内存中存在，而变量x先是指向1的标签，在赋值后变成了指向5的标签。
更多内存细节可以参考我另一篇博客。

### python的间接引用机制

### 可变类型和不可变类型
在python中将类型分为了可变类型和不可变类型，分别有：
可变类型：列表，字典
不可变类型：int、float、string、tuple
我们可以这样简单地来理解可变类型和不可变类型：在修改该类型变量时是否产生新对象，如果是在原对象上进行修改，为可变对象，如果是产生新的对象，则是不可变对象。那么怎么判断是否产生新的对象呢？我们可以用python内建id()函数来判断，这个函数返回对象在内存中的位置，如果内存位置有变动，表明变量指向的对象已经被改变。

### python传参时可变类型和不可变类型的区别
事实上，对于python的函数传递而言，我们不能简单地用传值或者传址来定义参数传递，我们从上一部分中可变类型和不可变类型的角度来分析：
* 在参数传递时，实参将标签复制给了实参，这个时候形参和实参都是指向同一个对象。
* 在函数内修改形参，
    * 对于不可变类型变量而言：因为不可变类型变量特性，修改变量需要新创建一个对象，形参的标签转而指向新对象，而实参没有变
    * 对于可变类型变量而言，因为可变类型变量特性，直接在原对象上修改，因为此时形参和实参都是指向同一个对象，所以，实参指向的对象自然就被修改了。
到这里，应该就不难理解为什么在"python的参数传递"部分，test1.py和test2.py执行完两种完全不同的结果了(test1.py传入不可变类型int，实参未被函数修改。而test2.py传入可变类型list，实参被修改)。

### 在业务逻辑中使用
上面说到了python传递参数的特性，那么如果我们要在函数中修改一个不可变对象的实参，又或者是在函数中不修改可变类型的实参，那该怎么做呢？  
首先，如果要在函数中修改一个不可变参数的实参，最简单也最实用的办法就是传入这个参数同时返回这个参数，因为虽然是同一个变量，在传入和返回时这个变量已经指向了不同的对象：

    def test(num):   #num参数指向对象5   
        mum += 10    #num参数指向新对象15
        return num   #返回num，此时num为15
    print test(5)

然后，如果要在函数中不修改可变参数的实参，这个时候就需要引用另一个模块：copy，我们可以看下面的例子：


### 相互引用
### 什么情况下要使用deepcopy
