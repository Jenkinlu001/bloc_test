# 浅谈I2C协议

## I2C简介
I2C,全称为Inter-Integrated Circuit，即板级协议，传输距离较短，是一种串行通信总线，由Philip公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展。
## I2C特点
对于嵌入式工程师而言，肯定对I2C协议不会陌生，协议有以下特点：
* 两线制，一根时钟线，一根数据线
* 主从结构，支持一主多从和多主多从，主机负责控制时钟线来生成start，stop等信号，主机具有完全掌控权。
* 主从之间通过地址进行寻址，地址有7位和10位之分
由于是主从结构，不支持双向通信，双线制中仅有SDA用于数据传输，主机进行时序控制，同时时序有一定的伸缩性，所以I2C位半双工协议，且传输速率在同等条件下劣于其他协议，如spi，串口。它的优势在于在不扩展IO资源的情况下支持主机与多从机之间的通信，节省资源IO这个特点在大多应用场景中都是不可忽略的优势。最具代表性的是在传感器应用领域，通常一个设备带有多个传感器，串口协议只支持1对1通信，spi通信除本身需要的3根信号线以外，每多一个设备就需要多增加一根片选线(尽管实际应用中有优化方案，对资源的要求依旧较高)，使用I2C协议是再合适不过了。  

## I2C协议时序
时序是一个协议最基础的部分了，一切数据的传输都起源于时序的控制，通信双方如果要进行数据同步，那么肯定需要约定开始和结束信号格式，以及通信时数据传输的行为，依据这个约定双方才能实现时序的生成，传输和解析。  
我们先来看看I2C的开始信号和结束信号。  
TODO
如图所示，在SCL高电平期间在SDA线上生成一个下降沿，即为一个开始信号，所有挂在I2C总线上的从设备都可以收到这个起始信号，表示接下来要接收数据了。
按照I2C协议的规定，在数据传输时，SCL高电平期间,SDA不允许电平跳变，只有在SCL低电平时才允许SDA改变电平状态。  
它的整体时序是这样的：
TODO
正因为i2c是主从结构，通信双方无法自主地进行双向通信，一切的行为由主机进行控制，所以有必要约定通信时的格式，它的格式这样的：
TODO
### I2C传输数据特点
* SCL和SDA配置成开漏引脚，外加上拉电阻，空闲时刻SCL和SDA保持高电平。  
* 一次传输8位有效字节，每次传输的字节数不受限制  
* 每一个字节最后都带有一个ACK位，用作从机回复  
* 传输字节以MSB的形式，即一个字节高位在前  

###关于ACK
每一个字节后面都必须跟有一个ack位，ack的作用是检测从机是否收到了8位数据，具体的操作是：

    在数据传输的第九位，主机释放SDA的控制权，从程序角度来说就是将SDA线设置为输入，由从机来控制SDA线的电平。  
    在ack时钟之后，主机检测到SDA被拉低，表明从机已回复(ACK)，否则从机无回复(NACK)。如果检测NACK，主机必须发送一个stop信号中断这次传输。  

以下5中情况将导致从机生成NACK(即无回复)：
* bus上指定的地址没有设备
* 从机正在执行其他实时性的工作，如中断，暂时无法回复
* 在传输数据时，从机无法识别数据
* 从机无法再接收更多的字节
* 通信结束，主机生成一个stop信号，不需要回复


关于时序的问题，我想各位已经听得耳朵都要起茧了，博主只是捎带巩固一下，在这里，我们真正需要了解清楚的问题是，I2C的时序和数据格式为什么是这样的？  
是的，不光要知道是什么，当然还要多问几句为什么。  

## 从从机角度出发
我想，大多数做嵌入式开发的工程师尽管对I2C不陌生，但是应该很少有人写过I2C从机的gpio软件实现，我们通常了解的是主机在通信过程中是怎么交互的，今天，我们就从从机的角度来看看到底主从机之间是怎么交互的。  

### 检测start信号
在空闲时刻SDA线总是保持高电平，从机必须时刻检测SDA电平是否有下降沿产生，一旦检测到SDA下降沿信号，再根据SCL的电平状态判断是否为start信号，如果是start信号，开始接收下一个字节数据，作为地址和读写位。  
为什么要同时检测SCL的电平状态呢？仅仅通过SDA下降沿是无法判断是否是起始信号的，因为可能主机在与总线上其他设备进行通信。  
在程序实现时，检测SDA的下降沿可以由中断实现，在中断服务程序中检测SCL电平。  

### 接收地址和读写位
一般情况下，为7位地址。读写位用来指明数据发送方向，如果此位为写，则从机进入接收程序，如果此位为读，从机开始发送数据。  
接收地址信号伪程序实现：
```C
for(int i=0;i<7;i++){
    /*低电平时主机发送一位数据，发送1拉高数据线，发送0拉低数据线，作为从机只需要等待一个时钟周期，在高电平时立即读取数据*/
    wait_scl_low;
    wait_scl_high;
    /*高位在前，最后一位为读写位，先移位再放数据*/
    val <<= 1
    /*读sda电平，作为有效数据位*/
    val |= sda_level;
}
val <<= 1
/*等待一个时钟周期*/
wait_scl_low;
wait_scl_high;
/*接收读写位*/
val |= sda_level;
if(val == self_i2c_slave_addr){
    /*当检测到总线上的地址为自身地址时，发送ACK信号，等待时钟线被拉低，因为高电平时不能操作，从机配置SDA为输出，获得SDA的控制权，拉低SDA回复ACK*/
    wait_scl_low;
    set_sda_mode_outout;
    set_sda_low;
    wait_scl_high;
}
```

### 主机写模式以及检测stop信号
如果最后的读写位为写，从机进入读数据模式，从机的读数据与上述流程一致。只是需要注意的是，在一个byte的ACK位回复之后，下一个时钟脉冲需要判断主机是否发送了stop信号，检测方法就是在下一个时钟周期中，当SCL线为高电平时，SDA线是否有上升沿产生，检测方法为：

    /*等待scl高电平*/
    wait_scl_high;
    /*在scl跳到高电平时立马存下sda的起始状态*/
    before = sda_level;
    /*不断检测在scl高电平期间sda是否有下降沿*/
    while(scl_level_is_high){
        after = sda_level;
        /*此时sda为高，初始值为低，表明在scl高期间sda有下降沿*/
        if((before == low) && (after == high)){
            detect_stop_signal;
            return;
        }
    }
这个检测的前提条件是：
* gpio的采样率要远高于I2C的采样率，这样在scl高电平期间才能多次对比sda的状态。在普通i2c模式下是满足的，i2c标准模式为100KHZ，快速模式为400KHZ，而gpio的采样率一般为几M到几十M不等，但是在fast-mode PLUS(1M bit/s)和high-speed mode(3.4M bit/s)中需要多做考虑。  
* 满足第一点的条件下，sda的上升沿跳变不能太靠近scl的高点平跳变。因为在scl从低电平到高电平时，程序还没来得及进行初始值采样，sda已经产生了上升沿跳变，这时候采到的sda初始值已经是高电平，导致检测不到上升沿跳变。也就是在上文中的wait_scl_high;before = sda_level;两条指令之间就产生了sda上升沿的跳变。

### 主机读模式
如果主机发送完地址之后，读写位为读信号，设备就需要在下一个时钟周期开始发送数据，伪代码程序实现是这样的：
```C
set_sda_output;
for(int i=0;i<8;i++){
    wait_scl_low;
    if(byte_to_send & 0x80){
        set_sda_high;
    }
    else{
        set_sda_low;
    }
    wait_scl_high;
    byte_to_send >>= 1;
}
wait_scl_low;
set_sda_input;
wait_scl_high;
if(sda == low){
    get_ack();
}
else{
    get_nack;
}
```

### 主机端实现
上文中写到了从机端的实现,接下来看看主机端的软件实现，主机端的实现与从机端最主要的区别就是主机端控制scl时钟线，下面是主机端发送数据的伪代码实现：
```C
/*start信号*/
set_sda_output_high;
set_scl_output_high;
set_sda_low;
delay_for_while;
/*发送8位数据*/
for(int i=0;i<8;i++){
    set_scl_low;
    if(byte_to_send & 0x80){
        set_sda_high;
    }else{
        set_sda_low;
    }
    delay_for_while;
    set_scl_high;
    delay_for_while;
}
/*释放sda线，等待从机生成ack信号*/
set_sda_input;
set_scl_low;
delay_for_while;
set_sda_high;
if(sda == low){
    get_ack;
}else{
    get_nack;
}
delay_for_while;
```










